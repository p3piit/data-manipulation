---
title: "Subsetting with `dplyr`"
---

While Base R subsetting is powerful and flexible, the `dplyr` package provides a more readable and expressive way to manipulate data frames. As part of the tidyverse, it uses a consistent, intuitive grammar for data manipulation built around a set of “verbs.” Two of the most commonly used verbs are `filter()`, for subsetting rows based on conditions, and `select()`, for subsetting columns. These functions make code cleaner and easier to read, especially when combined with the pipe operator (`|>` or `%>%`).

First of all, we make sure `dplyr` is loaded and that the bfi dataset is available:

```{r}
library(dplyr)
data(bfi, package = "psychTools")
```

The `filter()` function allows us to keep only the rows that satisfy one or more logical conditions. It works similarly to Base R’s logical subsetting, but the syntax is simpler and does not require commas or explicit logical connectors between conditions. Instead of chaining conditions with `&`, you simply separate them by commas.

Here we replicate the logical filter from before, selecting male participants younger than 50 with at least a bachelor’s degree, while excluding missing education values:

```{r}
bfi3 <- filter(bfi, age < 50, gender == 1, !is.na(education), education >= 4)
```

We can verify that the result matches the subset created earlier with Base R:

```{r, echo=FALSE}
filter <- with(bfi, age < 50 & gender == 1 & !is.na(education) & education >= 4)
bfi2 <- bfi[filter, ]
```

```{r}
sum(bfi2 - bfi3, na.rm = TRUE)
```

If the result is zero, it means both subsets contain the same data.

`filter()` is extremely flexible. You can use all the standard logical operators, and you can filter on complex conditions involving multiple variables. For instance, you might want to select only respondents who are female (`gender == 2`) and have missing values in education:

```{r}
filter(bfi, gender == 2, is.na(education))
```

Or select those who are under 40 or have high education levels:

```{r}
filter(bfi, age < 40 | education >= 5)
```

You can also apply functions inside conditions, such as filtering by the median age:

```{r}
filter(bfi, age > median(age, na.rm = TRUE))
```


The `select()` function in `dplyr` works similarly but targets columns instead of rows. It allows you to choose, exclude, or reorder variables using an expressive, concise syntax.

To extract a few specific columns, you can simply name them directly:

```{r}
tmp <- select(bfi, gender, age, education)
head(tmp)
```

To exclude columns, prefix their names with a minus sign:

```{r}
tmp <- select(bfi, -gender, -education)
head(tmp)
```

You can also select a contiguous range of columns using the colon operator `:`:

```{r}
tmp <- select(bfi, C1:O5)
head(tmp)
```

The real power of `select()` comes from its helper functions, which let you choose columns by name patterns rather than explicitly. For example:

```{r}
tmp <- select(bfi, starts_with("A"))
head(tmp)
```

This command selects all columns whose names begin with the letter “A.” You can combine multiple patterns as well:

```{r}
tmp <- select(bfi, starts_with(c("A", "E"), ignore.case = FALSE))
head(tmp)
```

Finally, `select()` also accepts numeric indexing, letting you select or exclude columns by position:

```{r}
tmp <- select(bfi, 1:10)     # First 10 columns  
tmp <- select(bfi, -(1:10))  # Exclude first 10 columns  
head(tmp)
```


Using `filter()` and `select()` together, possibly combined with the pipe operator, makes subsetting code both efficient and easy to read. For example, this chain extracts participants under 50, selects only relevant variables, and previews the first rows—all in one concise statement:

```{r}
bfi |>
  filter(age < 50) |>
  select(gender, age, education) |>
  head()
```

In just a few lines, `dplyr` allows for clear, structured data subsetting that reads like a logical sequence of steps. This simplicity and expressiveness are what make `dplyr` the best tool for most modern R workflows.

```{webr-r}
#| autorun: true
#| context: setup
library(psychTools)
library(dplyr)
data(bfi, package = "psychTools")
```

::: practice

## Practice

Use `dplyr` subsetting functions to select the same subset as in the previous practice exercise (the five neuroticism items for female minors out of the `bfi` data).

:::: {.panel-tabset}
## {{< var tab_title.editor >}}

```{webr-r}

```


## {{< var tab_title.solution >}}

```{r}
bfi %>%
  filter(gender == 2, 
         age < 18) %>%
  select(N1:N5)
```

















